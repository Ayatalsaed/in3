import Client from '../../client/Client'
import {simpleDecode,simpleEncode, methodID} from 'ethereumjs-abi' 
import {toBuffer,toChecksumAddress,privateToAddress} from 'ethereumjs-util' 
import * as ETx from 'ethereumjs-tx' 
import { toHex} from '../../util/util'

export type BlockType = number | 'latest' | 'earliest' | 'pending'
export type Quantity = number | string
export type Hash = string 
export type Address = string
export type Data = string
export type Transaction = {
    /** 20 Bytes - The address the transaction is send from. */
    from : Address
    /** (optional when creating new contract) 20 Bytes - The address the transaction is directed to.*/
    to : Address
    /** Integer of the gas provided for the transaction execution. eth_call consumes zero gas, but this parameter may be needed by some executions. */
    gas : Quantity
    /** Integer of the gas price used for each paid gas.  */
    gasPrice : Quantity
    /** Integer of the value sent with this transaction. */
    value: Quantity
    /** 4 byte hash of the method signature followed by encoded parameters. For details see Ethereum Contract ABI.*/
    data : string
}
export type TransactionReceipt = {
    /** 32 Bytes - hash of the block where this transaction was in. */
    blockHash: Hash
    /** block number where this transaction was in.*/
    blockNumber: BlockType
    /** 20 Bytes - The contract address created, if the transaction was a contract creation, otherwise null.*/
    contractAddress: Address 
    /** The total amount of gas used when this transaction was executed in the block. */
    cumulativeGasUsed: Quantity 
    /** 20 Bytes - The address of the sender. */
    from: Address 
    /** 20 Bytes - The address of the receiver. null when it’s a contract creation transaction.*/
    to: Address
    /** The amount of gas used by this specific transaction alone. */
    gasUsed: Quantity
    /** Array of log objects, which this transaction generated. */
    logs: Log[]
    /** 256 Bytes - A bloom filter of logs/events generated by contracts during transaction execution. Used to efficiently rule out transactions without expected logs.*/
    logsBloom: Data
    /** 32 Bytes - Merkle root of the state trie after the transaction has been executed (optional after Byzantium hard fork EIP609)*/
    root: Hash
    /** 0x0 indicates transaction failure , 0x1 indicates transaction success. Set for blocks mined after Byzantium hard fork EIP609, null before. */
    status: Quantity 
    /** 32 Bytes - hash of the transaction. */
    transactionHash: Hash
    /** Integer of the transactions index position in the block. */
    transactionIndex: Quantity
}
export type TransactionDetail = {
    /**  32 Bytes - hash of the transaction. */
    hash: Hash 
    /** the number of transactions made by the sender prior to this one.*/
    nonce: Quantity 
    /** 32 Bytes - hash of the block where this transaction was in. null when its pending.*/
    blockHash: Hash
    /** block number where this transaction was in. null when its pending.*/
    blockNumber: BlockType
    /** integer of the transactions index position in the block. null when its pending.*/
    transactionIndex: Quantity 
    /** 20 Bytes - address of the sender.*/
    from: Address 
    /** 20 Bytes - address of the receiver. null when its a contract creation transaction. */
    to: Address 
    /**  value transferred in Wei.*/
    value: Quantity
    /** gas price provided by the sender in Wei.*/
    gasPrice: Quantity
    /** gas provided by the sender. */
    gas: Quantity
    /** the data send along with the transaction. */
    input: Data
    /** the standardised V field of the signature.*/ 
    v: Quantity
    /** the standardised V field of the signature (0 or 1).*/
    standardV: Quantity
    /** the R field of the signature.*/
    r: Quantity
    /** raw transaction data */
    raw: Data
    /** public key of the signer. */
    publicKey: Hash
    /** the chain id of the transaction, if any. */
    chainId: Quantity
    /** creates contract address */
    creates: Address
    /** (optional) conditional submission, Block number in block or timestamp in time or null. (parity-feature)    */
    condition: any 
 }

export type Block = {
     /**  The block number. null when its pending block */
    number: Quantity
    /** hash of the block. null when its pending block */
    hash: Hash
    /** hash of the parent block */
    parentHash: Hash
    /** 8 bytes hash of the generated proof-of-work. null when its pending block. Missing in case of PoA. */
    nonce: Data
    /** SHA3 of the uncles data in the block */
    sha3Uncles: Data
    /** 256 Bytes - the bloom filter for the logs of the block. null when its pending block */
    logsBloom: Data
    /** 32 Bytes - the root of the transaction trie of the block */
    transactionsRoot: Data
    /** 32 Bytes - the root of the final state trie of the block */
    stateRoot: Data
    /** 32 Bytes - the root of the receipts trie of the block */
    receiptsRoot: Data
    /** 20 Bytes - the address of the author of the block (the beneficiary to whom the mining rewards were given)*/
    author: Address     
    /** 20 Bytes - alias of ‘author’*/
    miner: Address 
    /** integer of the difficulty for this block */
    difficulty: Quantity
    /** integer of the total difficulty of the chain until this block */
    totalDifficulty: Quantity
    /** the ‘extra data’ field of this block */
    extraData: Data 
    /** integer the size of this block in bytes */
    size: Quantity
    /** the maximum gas allowed in this block */
    gasLimit: Quantity
    /** the total used gas by all transactions in this block */
    gasUsed: Quantity
    /** the unix timestamp for when the block was collated */
    timestamp: Quantity
    /** Array of transaction objects, or 32 Bytes transaction hashes depending on the last given parameter */
    transactions: (Hash|Transaction)[]
    /** Array of uncle hashes */
    uncles: Hash[]
    /** PoA-Fields */
    sealFields: Data[]
}
export type Log = {
    /** true when the log was removed, due to a chain reorganization. false if its a valid log. */
    removed: boolean
    /** integer of the log index position in the block. null when its pending log. */
    logIndex: Quantity
    /** integer of the transactions index position log was created from. null when its pending log. */
    transactionIndex: Quantity
    /** Hash, 32 Bytes - hash of the transactions this log was created from. null when its pending log. */
    transactionHash: Hash
    /** Hash, 32 Bytes - hash of the block where this log was in. null when its pending. null when its pending log. */
    blockHash: Hash, 
    /** the block number where this log was in. null when its pending. null when its pending log. */
    blockNumber: Quantity
    /** 20 Bytes - address from which this log originated. */
    address: Address, 
    /**  contains the non-indexed arguments of the log. */
    data: Data
    /** - Array of 0 to 4 32 Bytes DATA of indexed log arguments. (In solidity: The first topic is the hash of the signature of the event (e.g. Deposit(address,bytes32,uint256)), except you declared the event with the anonymous specifier.) */
    topics: Data[] 
}

export type LogFilter = {
    /**  Quantity or Tag - (optional) (default: latest) Integer block number, or 'latest' for the last mined block or 'pending', 'earliest' for not yet mined transactions. */
    fromBlock: BlockType
    /** Quantity or Tag - (optional) (default: latest) Integer block number, or 'latest' for the last mined block or 'pending', 'earliest' for not yet mined transactions.*/
    toBlock: BlockType
    /** (optional) 20 Bytes - Contract address or a list of addresses from which logs should originate.*/
    address: Address
    /** (optional) Array of 32 Bytes Data topics. Topics are order-dependent. It’s possible to pass in null to match any topic, or a subarray of multiple topics of which one should be matching. */
    topics: (string|string[])[]
    /** å(optional) The maximum number of entries to retrieve (latest first). */
    limit: Quantity
}

export type TxRequest = {
    /** contract */
    to:Address

    /** the gas needed */
    gas: number

    /** the gasPrice used */
    gasPrice: number

    /** the nonce */
    nonce: number

    /** the value in wei */
    value: Quantity

    /** the ABI of the method to be used */
    method: string

    /** the argument to pass to the method */
    args: any[]

    /**raw private key in order to sign */
    pk:Hash

    /**  number of block to wait before confirming*/
    confirmations:number
}


export default class API {
    client: Client
    constructor(client:Client) {this.client=client}

    private send<T>(name:string, ...params:any[]):Promise<T> {
        return this.client.sendRPC(name,params||[])
        .then(r=>{
            if (r.error) throw new Error((r.error as any).message || r.error)
            return r.result as T
        })
    }

    /**
     * Returns the number of most recent block. (as number)
     */
    blockNumber() { 
        return this.send<string>('eth_blockNumber').then(parseInt) 
    }
    /**
     * Returns the current price per gas in wei. (as number)
     */
    gasPrice() { 
        return this.send<string>('eth_gasPrice').then(parseInt) 
    }

    /**
     * Executes a new message call immediately without creating a transaction on the block chain.
     */
    call(tx:Transaction, block:BlockType='latest') {
        return this.send<string>('eth_call',tx,block)
    }

    /**
     * Executes a new message call immediately without creating a transaction on the block chain.
     */
    callFn(to:Address, method:string, ...args:any[]) {
        const t = createCallParams(method,args||[])
        return this.send('eth_call',{to,data:t.txdata},'latest').then(t.convert)
    }

    /**
     * Returns the EIP155 chain ID used for transaction signing at the current best block. Null is returned if not available.
     */
    chainId() {
        return this.send<string>('eth_chainId') 
    }

    /**
     * Makes a call or transaction, which won’t be added to the blockchain and returns the used gas, which can be used for estimating the used gas.
     */
    estimateGas(tx:Transaction, block:BlockType='latest') {
        return this.send<string>('eth_estimateGas',tx,block).then(parseInt)
    }

    /**
     * Returns the balance of the account of given address in wei (as hex).
     */
    getBalance(address:Address, block:BlockType='latest') {
        return this.send<string>('eth_getBalance',address,block)
    }

    /**
     * Returns code at a given address.
     */
    eth_getCode(address:Address, block:BlockType='latest') {
        return this.send<string>('eth_getCode',address,block)
    }


    /**
     * Returns the value from a storage position at a given address.
     */
    getStorageAt(address:Address, pos:Quantity, block:BlockType='latest') {
        return this.send<string>('eth_getStorageAt',address,pos, block)
    }


    /**
     * Returns information about a block by hash.
     */
    getBlockByHash(hash:Hash, includeTransactions=false) {
        return this.send<Block>('eth_getBlockByHash',hash, includeTransactions)
    }

    /**
     * Returns information about a block by block number.
     */
    getBlockByNumber(block:BlockType='latest',includeTransactions=false) {
        return this.send<Block>('eth_getBlockByNumber',block, includeTransactions)
    }


    /**
     * Returns the number of transactions in a block from a block matching the given block hash.
     */
    getBlockTransactionCountByHash(block:Hash) {
        return this.send<string>('eth_getBlockTransactionCountByHash',block).then(parseInt)
    }


    /**
     * Returns the number of transactions in a block from a block matching the given block number.
     */
    getBlockTransactionCountByNumber(block:Hash) {
        return this.send<string>('eth_getBlockTransactionCountByNumber',block).then(parseInt)
    }

    /**
     * Polling method for a filter, which returns an array of logs which occurred since last poll.
     */
    getFilterChanges(id:Quantity) {
        return this.send<Log[]>('eth_getFilterChanges',id)
    }

    /**
     * Returns an array of all logs matching filter with given id.
     */
    getFilterLogs(id:Quantity) {
        return this.send<Log[]>('eth_getFilterLogs',id)
    }

    /**
     * Returns an array of all logs matching a given filter object.
     */
    getLogs(filter:LogFilter) {
        return this.send<Log[]>('eth_getLogs',filter)
    }




    /**
     * Returns information about a transaction by block hash and transaction index position.
     */
    getTransactionByBlockHashAndIndex(hash:Hash, pos:Quantity) {
        return this.send<TransactionDetail>('eth_getTransactionByBlockHashAndIndex',hash, pos)
    }


    /**
     * Returns information about a transaction by block number and transaction index position.
     */
    getTransactionByBlockNumberAndIndex(block:BlockType, pos:Quantity) {
        return this.send<TransactionDetail>('eth_getTransactionByBlockNumberAndIndex',block, pos)
    }

    /**
     * Returns the information about a transaction requested by transaction hash.
     */
    getTransactionByHash(hash:Hash) {
        return this.send<TransactionDetail>('eth_getTransactionByHash',hash)
    }

    /**
     * Returns the number of transactions sent from an address. (as number)
     */
    getTransactionCount(address:Address, block:BlockType='latest') {
        return this.send<string>('eth_getTransactionCount',address,block).then(parseInt)
    }

    /**
     * Returns the receipt of a transaction by transaction hash.
     * Note That the receipt is available even for pending transactions.
     */
    getTransactionReceipt(hash:Hash) {
        return this.send<TransactionReceipt>('eth_getTransactionReceipt',hash)
    }

    /**
     * Returns information about a uncle of a block by hash and uncle index position.
     * Note: An uncle doesn’t contain individual transactions.
     */
    getUncleByBlockHashAndIndex(hash:Hash, pos:Quantity) {
        return this.send<Block>('eth_getUncleByBlockHashAndIndex',hash, pos)
    }


    /**
     * Returns information about a uncle of a block number and uncle index position.
     * Note: An uncle doesn’t contain individual transactions.
     */
    getUncleByBlockNumberAndIndex(block:BlockType, pos:Quantity) {
        return this.send<Block>('eth_getUncleByBlockNumberAndIndex',block, pos)
    }

    /**
     * Returns the number of uncles in a block from a block matching the given block hash.
     */
    getUncleCountByBlockHash(hash:Hash) {
        return this.send<string>('eth_getUncleCountByBlockHash',hash).then(parseInt)
    }

    /**
     * Returns the number of uncles in a block from a block matching the given block hash.
     */
    getUncleCountByBlockNumber(block:BlockType) {
        return this.send<string>('eth_getUncleCountByBlockNumber',block).then(parseInt)
    }


    /**
     * Creates a filter in the node, to notify when a new block arrives. To check if the state has changed, call eth_getFilterChanges.
     */
    newBlockFilter() {
        return this.send<string>('eth_newBlockFilter')
    }


    /**
     * Creates a filter object, based on filter options, to notify when the state changes (logs). To check if the state has changed, call eth_getFilterChanges.
     * 
     * A note on specifying topic filters:
     * Topics are order-dependent. A transaction with a log with topics [A, B] will be matched by the following topic filters:
     * 
     * [] “anything”
     * [A] “A in first position (and anything after)”
     * [null, B] “anything in first position AND B in second position (and anything after)”
     * [A, B] “A in first position AND B in second position (and anything after)”
     * [[A, B], [A, B]] “(A OR B) in first position AND (A OR B) in second position (and anything after)”
     */
    newFilter(filter:LogFilter) {
        return this.send<string>('eth_newFilter',filter)
    }

    /**
     * Creates a filter in the node, to notify when new pending transactions arrive.
     * 
     * To check if the state has changed, call eth_getFilterChanges.
     */
    newPendingTransactionFilter() {
        return this.send<string>('eth_newPendingTransactionFilter')
    }
    

    /**
     * Uninstalls a filter with given id. Should always be called when watch is no longer needed. Additonally Filters timeout when they aren’t requested with eth_getFilterChanges for a period of time.
     */
    uninstallFilter(id:Quantity) {
        return this.send<Quantity>('eth_uninstallFilter')
    }
    
    /**
     * Returns the current ethereum protocol version.
     */
    protocolVersion() {
        return this.send<string>('eth_protocolVersion')
    }

   /**
     * Returns the current ethereum protocol version.
     */
    syncing() {
        return this.send<boolean|{
            startingBlock:string,
            currentBlock:string,
            highestBlock:string
            blockGap:string[][]
            warpChunksAmount:string
            warpChunksProcessed:string
        }>('eth_syncing')
    }


    /**
     * Creates new message call transaction or a contract creation for signed transactions.
     */
    sendRawTransaction(data:Data) {
        return this.send<string>('eth_sendRawTransaction',data)
    }

    /** sends a Transaction */
    async sendTransaction(args:TxRequest) {
        if (!args.pk) throw new Error('missing private key!')

        // prepare
        const tx = await prepareTransaction(args,this)

        // sign it
        const etx = new ETx({...tx, gasLimit:tx.gas})
        etx.sign(toBuffer(args.pk))
        const txHash = await this.sendRawTransaction(toHex(etx.serialize()))

        // send it
        return args.confirmations ? confirm(txHash, this, parseInt(tx.gas as string), args.confirmations) : txHash
    }

}


async function confirm(txHash:string, api:API, gasPaid:number, confirmations:number, timeout = 10) {
    let steps = 200
    const start = Date.now()
    while (Date.now() - start < timeout * 1000) {
      const receipt = await api.getTransactionReceipt(txHash)
      if (receipt) {
        if ( receipt.status !== '0x1' && gasPaid && gasPaid === parseInt(receipt.gasUsed as any))
          throw new Error('Transaction failed and all gas was used up')
        if (receipt.status && receipt.status == '0x0')
          throw new Error('The Transaction failed because it returned status=0')

        if (confirmations>1) {
            const start = parseInt(receipt.blockNumber as string)
            while ( start + confirmations -1 > await api.blockNumber())
               await new Promise(_ => setTimeout(_,10))

            return api.getTransactionReceipt(txHash)
        }
        return receipt
      }
  
      // wait a second and try again
      await new Promise(_ => setTimeout(_, Math.min(timeout * 200, steps *= 2)))
    }
  
    throw new Error('Error waiting for the transaction to confirm')
}

async function prepareTransaction(args:TxRequest, api?:API):Promise<Transaction> {
    const sender =  args.pk && toChecksumAddress(privateToAddress(toBuffer(args.pk)).toString('hex'))
    
    const tx:any ={}
    if (args.to) tx.to = toHex(args.to)
    if (args.method)
       tx.data = createCallParams(args.method, args.args).txdata
    if (sender || args.nonce)
       tx.nonce = toHex( args.nonce || (api && await api.getTransactionCount(sender,'pending'))  ) 
    if (api)
    tx.gasPrice = toHex( args.gasPrice || await api.gasPrice())
    tx.value = toHex( args.value || 0)
    if (sender) tx.from = sender
    tx.gas = toHex(args.gas || (api && await api.estimateGas(tx) || 3000000))

    
    return tx
}


function createCallParams(method:string, values:any[]):{txdata:string, convert:(a:any)=>any} {
    if (!method) throw new Error('method needs to be a valid contract method signature')
    if (method.indexOf('(')<0) method+='()'
    const methodRegex =/^\w+\((.*)\)$/gm
    let convert = null

    if (method.indexOf(':')>0) {
      const srcFullMethod=method;
      const retTypes = method.split(':')[1].substr(1).replace(')',' ').trim().split(',');
      convert = result=>{
        if (result)
          result = simpleDecode(method.replace('()','(uint)')+':('+retTypes.join()+')', Buffer.from(result.substr(2),'hex')).map((v,i)=>{
            if (Buffer.isBuffer(v)) return '0x'+v.toString('hex')
            if (v && v.ixor) return v.toString()
            if (retTypes[i]!=='string' && typeof v==='string' && v[1]!=='x')
               return '0x'+v
            return v
          })
        if (Array.isArray(result) && !srcFullMethod.endsWith(')'))
          result = result[0]
        return result
      }
      method = method.substr(0,method.indexOf(':'))
    }
  
    const m = methodRegex.exec(method)
    if (!m) throw new Error('No valid method signature for '+method)
    const types = m[1].split(',').filter(_=>_)
    if (values.length<types.length) throw new Error('invalid number of arguments. Must be at least '+types.length)
  
    return { txdata: '0x'+ (values.length 
    ? simpleEncode(method,...values).toString('hex')
    : methodID(method.substr(0, method.indexOf('(')), []).toString('hex') )
    , convert }
  }